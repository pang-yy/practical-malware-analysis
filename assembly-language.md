## Assembly Language

_This note covers Chapter 4, Chapter 6 and Chapter 21_

_Other popular instruction sets include ARM and MIPS_

- [Assembly Language](#assembly-language)
  - [x86 and x64 Architecture](#x86-and-x64-architecture)
    - [Register](#register)
      - [General Registers](#general-registers)
      - [Flags](#flags)
      - [Instruction Pointer](#instruction-pointer)
      - [Stack Pointer](#stack-pointer)
      - [Registers Summary](#registers-summary)
    - [Common Instructions](#common-instructions)
    - [`Rep` Instructions](#rep-instructions)
    - [The Stack](#the-stack)
  - [Difference in x64 system](#difference-in-x64-system)

### x86 and x64 Architecture

- [***endianness***](https://en.wikipedia.org/wiki/Endianness)
  - ***big-endian*** $\implies$ most significant byte is ordered first
  - ***little-endian*** $\implies$ least significant byte is ordered first
  - network data uses big-endian and an x86 program uses little-endian
    - Example: 127.0.0.1 is represented as 0x7F000001 over the network and 0x0100007F locally in memory
- Syntax: `[mnemonic] [zero_or_more_operands]`
  - ***mnemonic*** $=$ instruction to execute
  - ***operands*** $=$ information used by the instruction
    - ***Immediate*** operands $=$ fixed values
    - ***Register*** operands $=$ registers
    - ***Memory Address*** operands $=$ memory address denoted by a value, register, or equation between brackets, such as [eax]

#### Register

***Register*** is a small data storage available to the CPU

- ***General registers*** are used by the CPU during execution
- ***Segment registers*** are used to track sections of memory
- ***Status flags*** are used to make decisions
- ***Instruction pointers*** are used to keep track of the next instruction to execute

##### General Registers

- store data or memory addresses
- often used interchangeably
- some instructions use specific registers by definition
  - Example: multiplication and division instructions always use *EAX* and *EDX*
- *R8*-*R15* are 64-bit general-purpose registers and are not present in 32-bit systems (They are addressable in 32-bit, 16-bit, and 8-bit modes)
- *convention*: use of registers in a consistent fashion across compiled code
  - Example: *EAX* generally contains the return value for function calls

![some_registers](img/some_registers.png)
_Credits: <https://miro.medium.com/v2/resize:fit:809/0*H8eaKdSdiGQHM_V7>_

##### Flags

- *EFLAGS* register (*RFLAGS* in x64) is a status register
- *EFLAGS* is 32 bits (*RFLAGS is 64 bits*), and each bit is a flag
- The following flags are most important to malware analysis:
  - ***ZF*** : *zero flag* is set when the result of an operation is equal to zero; otherwise it is cleared
  - ***CF*** : *carry flag* is set when the result of an operation is too large or too small for the destination operand; otherwise it is clear
  - ***SF*** : *sign flag* is set when the result of an operation is negative or cleared when the result is positive, it also set when the *most significant bit* is set after an arithmetic operation
  - ***TF*** : *trap flag* is used for debugging, processor will execute one instruction at a time if this flag is set

##### Instruction Pointer

- *EIP* (*RIP* in x64) is the *instruction pointer*, or *program counter*
- contains the memory address of the next instruction to be executed
- When *EIP* is corrupted (points to a memory address that does not contain legitimate program code), CPU cannot fetch legitimate code to execute, so the program running will likely crash
- Control *EIP* can control what is executed by the CPU, making it a target of interest for attackers.

##### Stack Pointer

- *EBP* (*RBP* in x64) is the base pointer
  - stores memory address that points to the bottom of the stack
  - unchanged wintin a given function
  - program can use it as a placeholder to keep track of the location of local variables and parameters
- *ESP* (*RSP* in x64) is the stack pointer
  - stores memory address that points to the top of stack
  - value of this register changes as items are pushed on and popped off the stack
  - 

##### Registers Summary

|Registers|Description|
|---|---|
|EAX/RAX|Accumulator Register. Results of arithmetic operations are often stored in this register|
|EBX/RBX|Base Register, often used to store the Base address for referencing an offset|
|ECX/RCX|Counter Register and is often used in counting operations such as loops|
|EDX/RDX|Data Register. It is often used in multiplication/division operations|
|ESP/RSP|Stack Pointer. It points to the top of the stack and is used in conjunction with the Stack Segment register|
|EBP/RBP|Base Pointer. It is used to access parameters passed by the stack. It is also used in conjunction with the Stack Segment register|
|ESI/RSI|Source Index register. It is used for string operations. It is used with the Data Segment (DS) register as an offset|
|EDI/RDI|Destination Index register. It is also used for string operations. It is used with the Extra Segment (ES) register as an offset|
|R8-R15|These 64-bit general-purpose registers are not present in 32-bit systems|
|EFLAGS/RFLAGS|Status flags register consists of individual single-bit flags that can be either 1 or 0|
|EIP/RIP|Instruction Pointer, contains the address of the next instruction to be executed by the CPU|
|CS|Code Segment register points to the Code section in the memory|
|DS|Data Segment register points to the program's data section in the memory|
|SS|Stack Segment register points to the program's Stack in the memory|
|ES, FS, GS|These extra segment registers point to different data sections. These and the DS register divide the program's memory into four distinct data sections|

_Credits: TryHackMe x86 Architecture Room_

#### Common Instructions

|Instruction|Description|Syntax|
|---|---|---|
|`mov`|<ul><li>used to move data from one location to another </li><li> can move data into registers or RAM</li><li>operands surrounded by brackets are memory references to data</li></ul>|`mov <destination>, <source>` <br> (Intel syntax lists the destination operand first)|
|`lea`|<ul><li>load effective address</li><li>used to put a memory address into the destination</li><li>can also used to calculate values, e.g. `lea ebx, [eax*5+5]` where eax holds number rather than a memory address</li><li>this is shorter or more efficient for the compiler to use</li></ul>|syntax: `lea <destination>, <source>`|
|`inc` <br> `dec`|<ul><li>increment or decrement a register by one</li></ul>|`inc <register>` <br> `dec <register>`|
|`sub` <br> `add`|<ul><li>adds or subtracts a value from a destination operand</li><li>`sub` instruction modifies ***ZF*** and ***CF***</li></ul>|`sub <destination>, <value>` <br> `add <destination>, <value>`|
|`mul`|<ul><li>act on a predefined register</li><li>`imul` is the signed version of `mul`</li><li>result is stored as a 64-bit value across *EDX* and *EAX* (x86, not sure about x64)</li><li>*EDX* stores the most significant 32 bits</li><li>*EAX* stores the least significant 32 bits</li></ul>|`mul <value>`|
|`div`|<ul><li>act on a predefined register</li><li>`idiv` is the signed version of `div`</li><li>divides the 64 bits across *EDX* and *EAX* by *value* (again, not sure about x64)</li><li>*EAX* stores the result of the division operation</li><li>*EDX* stores the remainder</li></ul>|`div <value>`|
|`or` <br> `and` <br> `xor`|<ul><li>result is stored in the destination</li></ul>|`or <destination>, <source>` <br> `and <destination>, <source>` <br> `xor <destination>, <source>`|
|`shr` <br> `shl`|<ul><li>shift the bits in the destination operand to the right and left, respectively, by the number of bits specified in the count operand</li><li>bits shifted beyond the destination boundary are first shifted into the ***CF*** flag</li><li>zero bits are filled in during the shift</li><li>At the end of the shift instruction, the ***CF*** flag contains the last bit shifted out of the destination operand</li></ul>|`shr <destination>, <count>` <br> `shl <destination>, <count>`|
|`ror` <br> `rol`|<ul><li>similar to `shr` and `shl`, except the shifted bits that “fall off” with the shift operation are rotated to the other end</li></ul>|`ror <destination>, <count>` <br> `rol <destination>, <count>`|
|`nop`|<ul><li>no operation, does nothing</li></ul>|`nop`|
|`push` <br> `pop` <br> `call` <br> `leave` <br> `enter` <br> `ret`|<ul><li>stack instructions</li></ul>||
|`test`|<ul><li>similar to `and`</li><li>operands are not affected</li><li>only sets flag</li></ul>|`test <destination>, <source>`|
|`cmp`|<ul><li>similar to `sub`</li><li>operands are not affected</li><li>only sets flag</li></ul>|`cmp <destination>, <source>`|
|`jmp` <br> *many different *jump* instructions, refer online|<ul><li>there are conditional and unconditional jump</li></ul>|`jmp <destination>`|
|`movsx` <br> `cmpsx` <br> `stosx` <br> `scasx`|<ul><li>`x = b(byte), w(word), or d(double word)`</li><li>used for manipulating data buffers</li><li>work with any type of dat</li><li>*ESI* (source index register) and *EDI* (destination index register) are used in these operations</li><li>*ECX* is used as the counting variable</li><li>These instructions require a [prefix](#rep-instructions) to operate on data lengths greater than 1</li></ul>||

#### `Rep` Instructions

- In x86, the repeat prefixes are used for multibyte operations
- `rep` instruction increments the *ESI* and *EDI* offsets, and decrements *ECX*
- `rep` will repeat until ECX = 0
- `repe`/`repz` will repeat until ECX = 0 or ZF = 0
- `repne`/`repnz` will repeat until ECX = 0 or ZF = 1
- `movsb` is used to move a sequence of bytes from one location to another. The `rep` prefix is commonly used with `movsb` to copy a sequence of bytes, with size defined by *ECX*
- `rep` `movsb` is logical equivalent to C's `memcpy` function

|Instruction|Description|
|---|---|
|`repe cmpsb`|Used to compare two data buffers. *EDI* and *ESI* must be set to the two buffer locations, and *ECX* must be set to the buffer length. The comparison will continue until *ECX* $=$ 0 or the buffers are not equal|
|`rep stosb`|Used to initialize all bytes of a buffer to a certain value. *EDI* will contain the buffer location, and *AL* must contain the initialization value. This instruction is often seen used with `xor eax, eax`|
|`rep movsb`|Typically used to copy a buffer of bytes. *ESI* must be set to the source buffer address, *EDI* must be set to the destination buffer address, and *ECX* must contain the length to copy. Byte-by-byte copy will continue until *ECX* $=$ 0|
|`repne scasb`|Used for searching a data buffer for a single byte. *EDI* must contain the address of the buffer, *AL* must contain the byte you are looking for, and *ECX* must be set to the buffer length. The comparison will continue until *ECX* $=$ 0 or until the byte is found.|

#### The Stack

- Stack is allocated in a top-down format in memory
  - highest addresses are allocated and used first
  - when values are pushed onto the stack, smaller addresses are used
- Stack is used for short-term storage
  - stores local variables, parameters, and the return address
  - its primary usage is for the management of data exchanged between function calls. 
  - implementation of the management varies among compilers, but the most common convention is for local variables and parameters to be referenced relative to EBP.

### Difference in x64 system


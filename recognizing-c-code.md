## Recognizing C Code Constructs in Assembly

- [Recognizing C Code Constructs in Assembly](#recognizing-c-code-constructs-in-assembly)
  - [C main Method and Offsets](#c-main-method-and-offsets)
  - [Global and Local Variables](#global-and-local-variables)
  - [Arithmetic Operations](#arithmetic-operations)
  - [If Statements](#if-statements)
  - [Switch Statements](#switch-statements)
  - [Loops](#loops)
  - [Function Call Conventions](#function-call-conventions)
  - [Array](#array)
  - [Structs](#structs)
  - [Linked List Travesal](#linked-list-travesal)

### C main Method and Offsets

```c
int main(int argc, char ** argv)
```

- `argc` $=$ number of arguments on the command line
- `argv` $=$ pointer to an array of strings that contain the command-line arguments
- Example:

```c
// If the program is called like this
C:\> filetestprogram.exe -r filename.txt
// Then, 
argc = 3
argv[0] = filetestprogram.exe
argv[1] = -r
argv[2] = filename.txt
```

The following program,

<table>
<tr>
<td>In C</td> <td>In Assembly</td>
</tr>
<tr>
<td>

```c
int main(int argc, char* argv[]) {
  if (argc != 3) {return 0;}
  if (strncmp(argv[1], "-r", 2) == 0) {
      DeleteFileA(argv[2]);
  }
  return 0;
}
```

</td>
<td>

```assembly
004113CE    cmp     [ebp+argc], 3
004113D2    jz      short loc_4113D8
004113D4    xor     eax, eax
004113D6    jmp     short loc_411414
004113D8    mov     esi, esp
004113DA    push    2                   ; MaxCount
004113DC    push    offset Str2         ; "-r"
004113E1    mov     eax, [ebp+argv]
004113E4    mov     ecx, [eax+4]
004113E7    push    ecx                 ; Str1
004113E8    call    strncmp
004113F8    test    eax, eax
004113FA    jnz     short loc_411412
004113FC    mov     esi, esp
004113FE    mov     eax, [ebp+argv]
00411401    mov     ecx, [eax+8]
00411404    push    ecx                 ; lpFileName
00411405    call    DeleteFileA
```

</td>
</tr>
</table>

### Global and Local Variables

- ***Global variables*** are referenced by memory addresses
- ***Local variables*** are referenced by stack addresses

Program with *global variables*:

<table>
<tr>
<td>In C</td> <td>In Assembly</td>
</tr>
<tr>
<td>

```c
int x = 1;
int y = 2;
void main() {
  x = x+y;
  printf("Total = %d\n", x);
}
```

</td>

<td>

```assembly
00401003    mov     eax, dword_40CF60
00401008    add     eax, dword_40C000
0040100E    mov     dword_40CF60, eax
00401013    mov     ecx, dword_40CF60
00401019    push    ecx
0040101A    push    offset aTotalD    ;"total = %d\n"
0040101F    call    printf
```

</td>
</tr>
</table>

The global variable `x` is signified by `dword_40CF60`, a memory location at `0x40CF60`. Notice that `x` is changed in memory when *eax* is moved into `dword_40CF60` (0040100E)

Program with *local variables*:

<table>
<tr>
<td>In C</td> <td>In Assembly</td>
</tr>
<tr>
<td>

```c
void main() {
  int x = 0;
  int y = 1;
  x = x+y;
  printf("Total = %d\n", x);
}
```

</td>

<td>

```assembly
00401006    mov     dword ptr [ebp-4], 0
0040100D    mov     dword ptr [ebp-8], 1
00401014    mov     eax, [ebp-4]
00401017    add     eax, [ebp-8]
0040101A    mov     [ebp-4], eax
0040101D    mov     ecx, [ebp-4]
00401020    push    ecx
00401021    push    offset aTotalD    ; "total = %d\n"
00401026    call    printf
```

Assembly code with labelling by disassembler, `x` is `var_4`

```assembly
00401006    mov     [ebp+var_4], 0
0040100D    mov     [ebp+var_8], 1
00401014    mov     eax, [ebp+var_4]
00401017    add     eax, [ebp+var_8]
0040101A    mov     [ebp+var_4], eax
0040101D    mov     ecx, [ebp+var_4]
00401020    push    ecx
00401021    push    offset aTotalD  ; "total = %d\n"
00401026    call    printf
```

</td>
</tr>
</table>

The local variable `x` is located on the *stack* at a constant offset relative to *ebp*. The memory location `[ebp-4]` is used consistently throughout this function.

### Arithmetic Operations

<table>
<tr>
<td>In C</td> <td>In Assembly</td>
</tr>
<tr>
<td>

```c
int a = 0;
int b = 1;
a = a + 11;
a = a - b;
a--;
b++;
b = a % 3;
```

</td>

<td>

```assembly
; Notice that a (var_4) and b (var_8) are local variables
00401006    mov     [ebp+var_4], 0      ; initialize a by 1
0040100D    mov     [ebp+var_8], 1      ; initialize b by 1
00401014    mov     eax, [ebp+var_4]    ; copy a into eax
00401017    add     eax, 0Bh            ; add eax by 0x0b (increment a by 11)
0040101A    mov     [ebp+var_4], eax    ; store back into a
0040101D    mov     ecx, [ebp+var_4]    ; copy a into ecx
00401020    sub     ecx, [ebp+var_8]    ; subtract ecx by b
00401023    mov     [ebp+var_4], ecx    ; store back into a
00401026    mov     edx, [ebp+var_4]    ; copy a into edx
00401029    sub     edx, 1              ; decrement edx by 1
0040102C    mov     [ebp+var_4], edx    ; store back into a
0040102F    mov     eax, [ebp+var_8]    ; copy b into eax
00401032    add     eax, 1              ; increment eax by 1
00401035    mov     [ebp+var_8], eax    ; store back into b
00401038    mov     eax, [ebp+var_4]    ; copy a into eax
0040103B    cdq                         
0040103C    mov     ecx, 3              ; initialize ecx by 3
00401041    idiv    ecx                 ; divide edx:eax by value in ecx
00401043    mov     [ebp+var_8], edx    ; store remainder into b (edx stores remainder of division operator)
```

</td>
</tr>
</table>

### If Statements

Simple `if` statement:

<table>
<tr>
<td>In C</td> <td>In Assembly</td>
</tr>
<tr>
<td>

```c
int x = 1;
int y = 2;
if(x == y) {
    printf("x equals y.\n");
} else{
    printf("x is not equal to y.\n");
}
```

</td>

<td>

```assembly
00401006    mov     [ebp+var_8], 1
0040100D    mov     [ebp+var_4], 2
00401014    mov     eax, [ebp+var_8]
00401017    cmp     eax, [ebp+var_4]        ; compare and set ZF
0040101A    jnz     short loc_40102B        ; jump if not zero (equal)
0040101C    push    offset aXEqualsY_       ; "x equals y.\n"
00401021    call    printf
00401026    add     esp, 4
00401029    jmp     short loc_401038        ; jump so that skip the "else" part
0040102B  loc_40102B:                       ; will reach here only if not equal
0040102B    push    offset aXIsNotEqualToY  ; "x is not equal to y.\n"
00401030    call    printf
```

</td>
</tr>
</table>

Nested `if` statements:

<table>
<tr>
<td>In C</td> <td>In Assembly</td>
</tr>
<tr>
<td>

```c
int x = 0;
int y = 1;
int z = 2;
if(x == y) {
    if(z == 0) {
    printf("z is zero and x = y.\n");
    } else {
    printf("z is non-zero and x = y.\n");
    }
} else {
    if(z==0) {
    printf("z zero and x != y.\n");
    } else {
    printf("z non-zero and x != y.\n");
    }
}
```

</td>

<td>

```assembly
00401006    mov     [ebp+var_8], 0
0040100D    mov     [ebp+var_4], 1
00401014    mov     [ebp+var_C], 2
0040101B    mov     eax, [ebp+var_8]
0040101E    cmp     eax, [ebp+var_4]
00401021    jnz     short loc_401047
00401023    cmp     [ebp+var_C], 0
00401027    jnz     short loc_401038
00401029    push    offset aZIsZeroAndXY_   ; "z is zero and x = y.\n"
0040102E    call    printf
00401033    add     esp, 4
00401036    jmp     short loc_401045
00401038  loc_401038:
00401038    push    offset aZIsNonZeroAndX  ; "z is non-zero and x = y.\n"
0040103D    call    printf
00401042    add     esp, 4
00401045  loc_401045:
00401045    jmp     short loc_401069
00401047  loc_401047:
00401047    cmp     [ebp+var_C], 0
0040104B    jnz     short loc_40105C
0040104D    push    offset aZZeroAndXY_     ; "z zero and x != y.\n"
00401052    call    printf
00401057    add     esp, 4
0040105A    jmp     short loc_401069
0040105C  loc_40105C:
0040105C    push    offset aZNonZeroAndXY_ ; "z non-zero and x != y.\n"
00401061    call    printf
```

</td>
</tr>
</table>

### Switch Statements

<table>
<tr>
<td>In C</td> <td>In Assembly</td>
</tr>
<tr>
<td>

```c
switch(i) {
    case 1:
        printf("i = %d", i+1);
        break;
    case 2:
        printf("i = %d", i+2);
        break;
    case 3:
        printf("i = %d", i+3);
        break;
    default:
        break;
}
```

</td>

<td>

```assembly    
00401013    cmp     [ebp+var_8], 1
00401017    jz      short loc_401027
00401019    cmp     [ebp+var_8], 2
0040101D    jz      short loc_40103D
0040101F    cmp     [ebp+var_8], 3
00401023    jz      short loc_401053
00401025    jmp     short loc_401067
00401027  loc_401027:             ; case 1
...
0040103B    jmp     short loc_401067
0040103D  loc_40103D:             ; case 2
...
00401051    jmp     short loc_401067
00401053  loc_401053:             ; case 3
...
```       

</td>
</tr>
</table>

***Jump Table***

- for large, contiguous switch statements. The compiler optimizes the code to avoid needing to make so many comparisons

<table>
<tr>
<td>In C</td> <td>In Assembly</td>
</tr>
<tr>
<td>

```c
switch(i) {
    case 1:
        printf("i = %d", i+1);
        break;
    case 2:
        printf("i = %d", i+2);
        break;
    case 3:
        printf("i = %d", i+3);
        break;
    case 4:
        printf("i = %d", i+3);
        break;
    default:
        break;
}
```

</td>

<td>

```assembly
00401016    sub       ecx, 1
00401019    mov       [ebp+var_8], ecx
0040101C    cmp       [ebp+var_8], 3
00401020    ja        short loc_401082
00401022    mov       edx, [ebp+var_8]
00401025    jmp       ds:off_401088[edx*4] ÔÅµ
0040102C  loc_40102C:
...   
00401040    jmp       short loc_401082
00401042  loc_401042:
...   
00401056    jmp       short loc_401082
00401058  loc_401058:
...   
0040106C    jmp       short loc_401082
0040106E  loc_40106E:
...   
00401082  loc_401082:
00401082    xor       eax, eax
00401084    mov       esp, ebp
00401086    pop       ebp
00401087    retn
00401087  _main endp
00401088  off_401088  dd offset loc_40102C
0040108C              dd offset loc_401042
00401090              dd offset loc_401058
00401094              dd offset loc_40106E
```

</td>
</tr>
</table>

The more efficient assembly code in Listing 6-23 uses a jump table, shown at (00401088), which defines offsets to additional memory locations. The switch variable is used as an index into the jump table. 

In this example, ecx contains the switch variable, and 1 is subtracted from it in the first line. In the C code, the switch table range is 1 through 4, and the assembly code must adjust it to 0 through 3 so that the jump table can be properly indexed. The jump instruction at (00401025) is where the target is based on the jump table. 

In this jump instruction, edx is multiplied by 4 and added to the base of the jump table (0x401088) to determine which case code block to jump to. It is multiplied by 4 because each entry in the jump table is an address that is 4 bytes in size.

```TODO
EXPLANATION FOR JAMP TABLE/SWITCH
```

### Loops

`for` loops:

<table>
<tr>
<td>In C</td> <td>In Assembly</td>
</tr>
<tr>
<td>

```c
int i;
for(i=0; i<100; i++) {
    printf("i equals %d\n", i);
}
```

</td>

<td>

```assembly
00401004    mov     [ebp+var_4], 0        ; initialise i = 0
0040100B    jmp     short loc_401016
0040100D  loc_40100D:                   ; the following 3 instructions are to increment i
0040100D    mov     eax, [ebp+var_4]
00401010    add     eax, 1                
00401013    mov     [ebp+var_4], eax
00401016  loc_401016:
00401016    cmp     [ebp+var_4], 64h      ; compare i with 0x64 (100)
0040101A    jge     short loc_40102F      ; jump if greater or equal
0040101C    mov     ecx, [ebp+var_4]      
0040101F    push    ecx
00401020    push    offset aID            ; "i equals %d\n"
00401025    call    printf
0040102A    add     esp, 8
0040102D    jmp     short loc_40100D
```

</td>
</tr>
</table>

`while` loops:

<table>
<tr>
<td>In C</td> <td>In Assembly</td>
</tr>
<tr>
<td>

```c
int status=0;
int result = 0;
while(status == 0) {
  result = performAction();
  status = checkResult(result);
}
```

</td>

<td>

```assembly
00401036    mov     [ebp+var_4], 0
0040103D    mov     [ebp+var_8], 0
00401044  loc_401044:
00401044    cmp     [ebp+var_4], 0
00401048    jnz     short loc_401063
0040104A    call    performAction
0040104F    mov     [ebp+var_8], eax
00401052    mov     eax, [ebp+var_8]
00401055    push    eax
00401056    call    checkResult
0040105B    add     esp, 4
0040105E    mov     [ebp+var_4], eax
00401061    jmp     short loc_401044
```

</td>
</tr>
</table>

### Function Call Conventions

- Main code calls and temporarily transfers execution to function
- ***prologue*** - a few lines of code at the start of the function
  - prepares the stack and registers for use within the function
- ***epilogue*** 
  - restores the stack and registers to their state before the function was called
- Three most common calling conventions
  - ***cdecl***
  - ***stdcall***
  - ***fastcall***

***cdecl***

- parameters are pushed onto the stack from right to left
- caller cleans up the stack when the function is complete
- return value is stored in *EAX*

<table>
<tr>
<td>In C</td> <td>In Assembly</td>
</tr>
<tr>
<td>

```c
int test(int x, int y, int z);
int a, b, c, ret;
ret = test(a, b, c);
```

</td>

<td>

```assembly
push    c
push    b
push    a
call    test
add     esp, 12
mov     ret, eax
```

</td>
</tr>
</table>

***stdcall***

- similar to ***cdecl***, except ***stdcall*** requires the function called (*callee*) to clean up the stack when the function is complete
- so the instruction `add   esp, 12` would not be needed

***fastcall***

- the first few arguments (typically two) are passed in registers
- the most commonly used registers are *EDX* and *ECX* (the Microsoft *fastcall* convention)
- additional arguments are loaded from right to left
- the calling function are responsible for cleaning up the stack
- *fastcall* is often more efficient than other conventions

***`push` vs `mov`***

In addition to different calling conventions, compilers may also use different intructions to perform the same operation

Consider the following program,

<table>
<tr>
<td>In C</td> <td>In Assembly (for adder only)</td>
</tr>
<tr>
<td>

```c
int adder(int a, int b) {
    return a+b;
}
void main() {
    int x = 1;
    int y = 2;
    printf("the function returned the number %d\n", adder(x,y));
}
```

</td>

<td>

```assembly
; assembly code for the adder function is consistent across compilers
00401730 push ebp
00401731 mov ebp, esp
00401733 mov eax, [ebp+arg_0]
00401736 add eax, [ebp+arg_4]
; calling function are responsible for cleaning up the stack
00401739 pop ebp
0040173A retn
```

</td>
</tr>
</table>

Different calling conventions used by two different compilers:

<table>
<tr>
<td>Visual Studio Version</td> <td>GCC version</td>
</tr>
<tr>
<td>

```assembly
00401746    mov     [ebp+var_4], 1
0040174D    mov     [ebp+var_8], 2
; parameters for adder are pushed onto the stack before the call
00401754    mov     eax, [ebp+var_8]
00401757    push    eax
00401758    mov     ecx, [ebp+var_4]
0040175B    push    ecx
0040175C    call    adder
; restore stack pointer
00401761    add     esp, 8
; parameters for printf are pushed onto the stack before the call
00401764    push    eax
00401765    push    offset TheFunctionRet
0040176A    call    ds:printf
```

</td>

<td>

```assembly
00401085    mov     [ebp+var_4], 1
0040108C    mov     [ebp+var_8], 2
; parameters for adder are moved onto the stack before the call
00401093    mov     eax, [ebp+var_8]
00401096    mov     [esp+4], eax
0040109A    mov     eax, [ebp+var_4]
0040109D    mov     [esp], eax
004010A0    call    adder
; no need to restore stack pointer because it is never altered
; parameters for printf are moved onto the stack before the call
004010A5    mov     [esp+4], eax
004010A9    mov     [esp], offset TheFunctionRet
004010B0    call    printf
```

</td>
</tr>
</table>

_Even when the same compiler is used, there can be differences in calling conventions depending on the various settings and options_

### Array

Arrays are accessed using a base address as a starting point

<table>
<tr>
<td>In C</td> <td>In Assembly</td>
</tr>
<tr>
<td>

```c
// global array
int b[5] = {123,87,487,7,978};
void main() {
    int i;
    // local array
    int a[5];
    for(i = 0; i<5; i++) {
        a[i] = i;
        b[i] = i;
    }
}
```

</td>

<td>

```assembly
00401006    mov     [ebp+var_18], 0             ; this is for variable i
0040100D    jmp     short loc_401018
0040100F  loc_40100F:                           ; increment i
0040100F    mov     eax, [ebp+var_18]
00401012    add     eax, 1
00401015    mov     [ebp+var_18], eax
00401018  loc_401018:
00401018    cmp     [ebp+var_18], 5             ; check i < 5
0040101C    jge     short loc_401037
0040101E    mov     ecx, [ebp+var_18]           ; copy i into ecx (ecx is index)
00401021    mov     edx, [ebp+var_18]           ; copy i into edx
00401024    mov     [ebp+ecx*4+var_14], edx     ; equivalent to a[i] = i
00401028    mov     eax, [ebp+var_18]           ; copy i into eax
0040102B    mov     ecx, [ebp+var_18]           ; copy i into ecx (ecx is index)
0040102E    mov     dword_40A000[ecx*4], eax    ; equivalent to b[i] = i
00401035    jmp     short loc_40100F
```

</td>
</tr>
</table>

- base address of array `b` is to `dword_40A000`
- base address of array `a` is to `var_14`

### Structs

<table>
<tr>
<td>In C</td> <td>In Assembly</td>
</tr>
<tr>
<td>

```c
struct my_structure {
    int x[5];
    char y;
    double z;
};

struct my_structure *gms;

void test(struct my_structure *q) {
    int i;
    q->y = 'a';
    q->z = 15.6;
    for(i = 0; i<5; i++) {
        q->x[i] = i;
    }
}

void main() {
    gms = (struct my_structure *) malloc(sizeof(struct my_structure));
    test(gms);
}
```

</td>

<td>

Assembly code for the `main` function:

```assembly
00401050    push    ebp
00401051    mov     ebp, esp
00401053    push    20h
00401055    call    malloc
0040105A    add     esp, 4
0040105D    mov     dword_40EA30, eax
00401062    mov     eax, dword_40EA30
00401067    push    eax
00401068    call    sub_401000          ; call subroutine at 401000 ?
0040106D    add     esp, 4
00401070    xor     eax, eax
00401072    pop     ebp
00401073    retn    
```

Assembly code for the `test` function:

```assembly 
00401000    push    ebp
00401001    mov     ebp, esp
00401003    push    ecx
00401004    mov     eax,[ebp+arg_0]
00401007    mov     byte ptr [eax+14h], 61h
0040100B    mov     ecx, [ebp+arg_0]
0040100E    fld     ds:dbl_40B120
00401014    fstp    qword ptr [ecx+18h]
00401017    mov     [ebp+var_4], 0
0040101E    jmp     short loc_401029
00401020 loc_401020:
00401020    mov     edx,[ebp+var_4]
00401023    add     edx, 1
00401026    mov     [ebp+var_4], edx
00401029 loc_401029:
00401029    cmp     [ebp+var_4], 5
0040102D    jge     short loc_40103D
0040102F    mov     eax,[ebp+var_4]
00401032    mov     ecx,[ebp+arg_0]
00401035    mov     edx,[ebp+var_4]
00401038    mov     [ecx+eax*4],edx
0040103B    jmp     short loc_401020
0040103D loc_40103D:
0040103D    mov     esp, ebp
0040103F    pop     ebp
00401040    retn     
``` 

</td>
</tr>
</table>

```TODO
EXPLANATION FOR STRUCT
```

### Linked List Travesal

<table>
<tr>
<td>In C</td> <td>In Assembly</td>
</tr>
<tr>
<td>

```c
struct node {
    int x;
    struct node *next;
};
typedef struct node pnode;

void main() {
    pnode *curr;
    pnode *head;
    head = NULL;
    for(int i = 1; i <= 10; i++) {
        curr = (pnode*)malloc(sizeof(pnode));
        curr->x = i;
        curr->next = head;
        head = curr;
    }
    curr = head;
    while(curr) {
        printf("%d\n", curr->x);
        curr = curr->next;
    }
}
```

</td>

<td>

```assembly
CODDE IN ASSEMBLY
```

</td>
</tr>
</table>

```TODO
EXPLANATION FOR LINKED LIST
```